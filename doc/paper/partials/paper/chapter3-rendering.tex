\section{Rendering techniques}

\subsection{Volumetric rendering}
\label{section:volumetric-rendering}

\subsubsection{Definition}
\Gls{volumetricrendering} describes a technique for generating a visual representation of data that is stored in a 3D volume. 
This especically comes to use for visual effects that are volumetric in nature, like fluids, clouds, fire, smoke, fog and dust, which all are extremely difficult or even impossible to model with geometric primitives.
\\
In addition to rendering such effects, volumetric rendering has become essential to scientific applications like medical imaging, for which a typical 3D data volume is a set of 2D slice images acquired by a CT (computed tomography) or MRI (magnetic resonance imaging) scanner.
\emptyline
The data volume is also called a \textit{\gls{scalarfield}} or \textit{\gls{vectorfield}}, which associates a scalar value, or \textit{\gls{voxel}}, to every point in the defined space.
This can be imagined like a 3D grid, where each point holds a single number. This number could, for example, represent the density of a cloud at that very point.
A \gls{voxel} may also consist of more than just a single value, but rather a set, like an RGB color.

\subsubsection{Ray Marching with constant step}
To actually render the volume data, a method called \textit{\gls{raymarching}} is used. With it, the surface distance of the volumetric data is approximated by creating a ray from the camera to the object for each fragment processed in the fragment shader. The ray is then extended into the volume of the object and stepped forward until the surface is reached.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.7]
        \draw[-{Latex[length=2mm]},thick,cyan] (2.5,3) node[below right]{stepped forward} -- (4.75,4.125);
        \node[cyan] at (3.0,3.25) {\textbullet};
        \node[cyan] at (3.5,3.50) {\textbullet};
        \node[cyan] at (4.0,3.73) {\textbullet};
        
        \draw (0,0) -- (5,0) -- (5,5) -- (0, 5) -- (0, 0);
        \draw (2,1) -- (7,1) -- (7,6) -- (2, 6) -- (2, 1);
        \draw (0,0) -- (2,1); \draw (5,0) -- (7,1); \draw (5,5) -- (7,6); \draw (0,5) -- (2,6); 

        \draw[thick,red] (-1.5,1) node[below right]{camera ray} -- (2.5,3);

    \end{tikzpicture}
    \caption{A ray is created from the camera to the object. From there, it is extended into the volume.}
\end{figure}

\pagebreak
\noindent
In \gls{raymarching}, the algorithm only knows when it has reached the surface, or to be precise when it is inside the actual object volume.
\\
With this information, it is only possible to extend the ray in steps of a predefined length until the inside of the object is reached.
With a constant step, the approximation of the surface distance is exactly as precise as the size of the constant step.
\\
Once the ray is inside the actual volume, the functions returns the distance for this ray.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=1.2]
        \tikzset{edge/.style = {-{Latex[length=3mm]}}}
        \tikzset{smalledge/.style = {-{Latex[length=1mm]}}}

        % ray
        \draw[edge] (0,2) node[above,sloped,xshift=1cm]{ray} -- (10,3);
        \node (1) at (2,2.2) {\textbullet};
        \node (2) at (3,2.3) {\textbullet};
        \node (3) at (4,2.4) {\textbullet};
        \node (4) at (5,2.5) {\textbullet};
        \node (5) at (6,2.6) {\textbullet};
        \node (6) at (7,2.7) {\textbullet};
        \node[cyan] (7) at (8,2.8) {\textbullet};

        % surf dist
        \draw[red] (2,1.5) -- (2.5,2) -- (4,1.8) -- (5,1.5) -- (7.4,2) -- (7.7,4) -- (9,4.3);

        % ray steps
        \draw[smalledge] (1) edge[bend left=60] node [left]{} (2);
        \draw[smalledge] (2) edge[bend left=60] node [left]{} (3);
        \draw[smalledge] (3) edge[bend left=60] node [left]{} (4);
        \draw[smalledge] (4) edge[bend left=60] node [left]{} (5);
        \draw[smalledge] (5) edge[bend left=60] node [left]{} (6);
        \draw[smalledge] (6) edge[bend left=60] node [left]{} (7);

        % returns text
        \draw[cyan, shorten <=-0.2cm] (7) -- (9,3.7) -- (11,3.7) node[xshift=-1cm,above]{function returns};
        
        \end{tikzpicture}
    \caption{Traditional ray marching, the precision of which being directly dependent on the step size.}
\end{figure}

\noindent
An implementation of this algorithm can be seen in \autoref{lst:shader:raymarch:constantstep}. Note that the volume to be rendered in this example is just a simple sphere.
So in order to check if the ray is inside the volume, the function \lstinline[language=HLSL]{sphereHit()} is used.
\begin{lstlisting}[language=HLSL, numbers=left, caption=Implementation of a volume distance function for a sphere.,captionpos=b, label=lst:shader:raymarch:spherehit]
bool sphereHit(float3 position) {
    float4 sphere = float4(0, 1, 0, 1);
    return distance(sphere.xyz, position) < sphere.w;
}
\end{lstlisting}

\noindent
With that given, the raymarch function is implemented like so:

\begin{lstlisting}[language=HLSL, numbers=left, caption=Ray march function with constant step.,captionpos=b, label=lst:shader:raymarch:constantstep]
fixed4 raymarch(float3 position, float3 direction)
{
    for (int i = 0; i < MAX_STEPS; i++)
    {
        if (sphereHit(position))
            return fixed4(1,0,0,1);
        
        position += normalize(direction) * STEP_SIZE;
    }
    
    return fixed4(0,0,0,1);
}
\end{lstlisting}


\pagebreak
\subsubsection{Traditional Ray Marching}
It is obvious to see that, for a constant step ray march to result in an accurate approximation of the surface distance, the step size is required to be relatively small.
This has a direct impact on performance and thus, is not a viable solution for the problem.
\\
In traditional \gls{raymarching}, an optimization for that has been developed. The algorithm does not blindly step forward, but instead tries to get as close to the real distance as possible.
After the volume is reached, the step size is decreased and the ray steps out of the volume again. It then tries to approximate the surface distance by stepping back and forward repeatedly in continuously smaller steps, thus converging towards the exact intersection.
Once the step size falls below a certain threshold, the distance approximation is assumed to be precise enough and the value is returned for that ray march.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=1.2]
        \tikzset{edge/.style = {-{Latex[length=3mm]}}}
        \tikzset{smalledge/.style = {-{Latex[length=2mm]}}}

        % ray
        \draw[edge] (0,2) node[above,sloped,xshift=1cm]{ray} -- (10,3);
        \node (1) at (2,2.2) {\textbullet};
        \node (2) at (4,2.4) {\textbullet};
        \node (3) at (6,2.6) {\textbullet};
        \node[cyan] (4) at (8,2.8) {\textbullet};

        % surf dist
        \draw[red] (2,1.5) -- (2.5,2) -- (4,1.8) -- (5,1.5) -- (7.4,2) -- (7.7,4) -- (9,4.3);

        % reverse nodes
        \node[cyan] (5) at (7,2.7) {\textbullet};
        \node[cyan] (6) at (7.5,2.75) {\textbullet};

        % ray steps
        \draw[smalledge] (1) edge[bend left=60] node [left]{} (2);
        \draw[smalledge] (2) edge[bend left=60] node [left]{} (3);
        \draw[smalledge] (3) edge[bend left=60] node [left]{} (4);

        % rey reverse steps
        \draw[smalledge,cyan,shorten >=-0.1cm,shorten <=-0.1cm] (4) edge[bend left=60] node [left]{} (5);
        \draw[smalledge,cyan,shorten >=-0.1cm,shorten <=-0.1cm] (5) edge[bend left=60] node [left]{} (6);

        % close enough
        \draw[cyan, shorten <=-0.2cm] (6) -- (9,3.7) -- (11,3.7) node[xshift=-1cm,above]{step size small enough};
        
        \end{tikzpicture}
    \caption{The function returns the distance for this ray, which is the amount of steps times the step size.}
\end{figure}

\noindent
As clearly visible, the traditional \gls{raymarching} ends up with a more precise result and the amount of steps per ray could be relatively lower, ultimately saving performance. 
\\
However, there is still an issue. The algorithm may jump in and out of the volume, even if it would already be precise enough, essentially taking unnecessary steps.

\begin{lstlisting}[language=HLSL, numbers=left, caption=Traditional ray march function with converging surface distance approximation.,captionpos=b, label=lst:shader:raymarch:traditional]
fixed4 raymarch(float3 position, float3 direction)
{
    float stepSize = STEP_SIZE;
    float dirMultiplier = 1;
    for (int i = 0; i < MAX_STEPS; i++)
    {
        if (stepSize < MINIMUM_STEP_SIZE)
            return fixed4(1,0,0,1);

        if (sphereHit(position)) {
            // reduce step size by half and invert marching direction.
            stepSize /= 2;
            dirMultiplier = -1;
        } else {
            dirMultiplier = 1;
        }
        
        position += normalize(direction) * stepSize * dirMultiplier;
    }
    
    return fixed4(0,0,0,1);
}
\end{lstlisting}

\pagebreak
\subsubsection{Sphere Tracing}
An even better approach to approximate the intersection of the ray and the volume is called \textit{\gls{spheretracing}}. 
Instead of evaluating if the ray is inside the volume or not, an exact distance is measured to the scene. This distance is the minimum amount of space the algorithm can march along its ray without colliding with anything.
For that, a function group called \textit{\gls{sdf}s} is used.

\paragraph{Signed Distance Functions}
A \gls{sdf} returns the shortest distance from that a given point in space to some surface.
The sign of the returned value indicates wether that point is inside the surface or outside, hence the name.
\\
The \gls{sdf} $sdf$ for a point $p=(p_1, p_2, p_3)$ to the surface of a sphere $s=(s_1, s_2, s_3)$ with radius $R$ looks like this:
$$ sdf(p) = \sqrt{(s_1 - p_1)^2 + (s_2 - p_2)^2 + (s_3 - p_3)^2} - R $$

\noindent
This translates into a simple code snippet, mostly identical to the function \lstinline[language=HLSL]{sphereHit()} in \autoref{lst:shader:raymarch:spherehit}, except the distance is returned instead of a boolean.
\begin{lstlisting}[language=HLSL, caption=Implementation of a signed distance function for a sphere., label=lst:shader:raymarch:spheredistance]
float sphereDistance(float3 position) {
    float4 sphere = float4(0, 1, 0, 1);
    return distance(sphere.xyz, position) - sphere.w;
}
\end{lstlisting}